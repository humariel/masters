    def create_discriminator(self):
        # image input
        in_image = layers.Input(shape=[32,32,3])
        # ResBlocks
        D = ResnetBlockDown(in_image, 64)
        D = Attention(D, epsilon=1.0e-8)
        D = ResnetBlockDown(D, 128)
        D = ResnetBlockDown(D, 256)
        D = ResnetBlock(D, 512)
        D = layers.ReLU()(D)
        D = GlobalSumPooling2D()(D)
        #last layer
        D = layers.Flatten()(D)
        # real/fake output
        out1 = SpectralDense(1, epsilon=1.0e-8, kernel_initializer="orthogonal", activation='sigmoid', name='out_fake')(D)
        # class label output
        out2 = SpectralDense(self.n_classes, epsilon=1.0e-8, kernel_initializer="orthogonal", activation='softmax', name='out_aux')(D)
        # define model
        model = tf.keras.Model(in_image, [out1, out2], name="discriminator")
        # compile model
        opt = tf.keras.optimizers.Adam(lr=0.000025, beta_1=0.0, beta_2=0.9)
        model.compile(
            loss=['hinge', 'sparse_categorical_crossentropy'], 
            optimizer=opt,
            metrics={'out_fake': 'accuracy', 'out_aux': tf.keras.metrics.SparseCategoricalAccuracy()})
        model.summary()
        return model

    def create_generator(self):
        # label input
        z = layers.Input(shape=(self.latent_dim,))
        # this will be our label
        y = layers.Input(shape=(1,), dtype='float32')

        y_emb = SpectralDense(self.latent_dim, use_bias=False, epsilon=1.0e-8, kernel_initializer="orthogonal")(y)
        c = layers.Concatenate()([z, y_emb])
        G = SpectralDense(4*4*384, use_bias=False, epsilon=1.0e-8, kernel_initializer="orthogonal")(c)
        G = layers.Reshape((4,4,384))(G)
        # ResBlocks
        G = ResnetBlockUp(G, c, 384)
        G = ResnetBlockUp(G, c, 192)
        G = Attention(G, epsilon=1.0e-8)
        G = ResnetBlockUp(G, c, 96)
        # End part
        G = ConditionalBatchNormalization(G, c, momentum=0.99, epsilon=1.0e-8)
        G = layers.ReLU()(G)
        G = SpectralConv2D(3, 3, epsilon=1.0e-8, padding="same", kernel_initializer="orthogonal")(G)
        G = layers.Activation("tanh")(G)
        # define model
        model = tf.keras.Model([z, y], G, name="generator")
        model.summary()
        return model

    def define_gan(self):
        # make weights in the discriminator not trainable
        self.discriminator.trainable = False
        # connect the outputs of the generator to the inputs of the discriminator
        gan_output = self.discriminator(self.generator.output)
        # define gan model as taking noise and label and outputting real/fake and label outputs
        model = tf.keras.Model(self.generator.input, gan_output)
        # compile model
        opt = tf.keras.optimizers.Adam(lr=0.000025, beta_1=0.0, beta_2=0.9)
        model.compile(loss=['hinge', 'sparse_categorical_crossentropy'], optimizer=opt)
        return model
